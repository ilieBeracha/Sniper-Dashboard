import { Node, Edge } from "@xyflow/react";
import { RuleDefinition, RuleActionStep, RuleExecution } from "../service/ruleService";

// You’ll pass in the full RuleDefinition plus its action‐steps here.
export function generateFlowFromConfig(
  def: RuleDefinition,
  actions: RuleActionStep[],
  executions: RuleExecution[],
): {
  nodes: Node[];
  edges: Edge[];
  labelFromLogic: (rule: any) => string;
} {
  const nodes: Node[] = [];
  const edges: Edge[] = [];

  // starting coords
  const x = 100;
  let y = 60;

  // 1) Trigger node
  nodes.push({
    id: "trigger",
    type: "trigger",
    position: { x, y },
    data: { label: `Trigger: ${def.name}` },
    style: {
      background: "#000",
      color: "#fff",
      border: "1px solid #222",
    },
  });

  let lastNodeId = "trigger";

  // 2) Condition nodes parsed from JSONLogic (generated by UI)
  const logicObj: any = def.logic || {};
  let conditions: any[] = [];
  let combinatorLabel = "";
  if (Array.isArray(logicObj.and)) {
    conditions = logicObj.and;
    combinatorLabel = "AND";
  } else if (Array.isArray(logicObj.or)) {
    conditions = logicObj.or;
    combinatorLabel = "OR";
  }

  if (conditions.length) {
    y += 120;
    // Add a combinator node summarising logic type
    const combId = "logic-comb";
    nodes.push({
      id: combId,
      type: "default",
      position: { x, y },
      data: { label: `Logic: ${combinatorLabel} (${conditions.length})` },
      style: {
        background: "#111",
        color: "#fff",
        border: "1px solid #555",
      },
    });
    edges.push({
      id: `e-${lastNodeId}-${combId}`,
      source: lastNodeId,
      target: combId,
      type: "smoothstep",
    });
    lastNodeId = combId;
  }

  const labelFromLogic = (rule: any): string => {
    if (rule["=="]) {
      const [left, right] = rule["=="];
      return `${left.var} == ${right}`;
    }
    if (rule["!="]) {
      const [left, right] = rule["!="];
      return `${left.var} != ${right}`;
    }
    if (rule[">"]) {
      const [left, right] = rule[">"];
      return `${left.var} > ${right}`;
    }
    if (rule[">="]) {
      const [left, right] = rule[">="];
      return `${left.var} >= ${right}`;
    }
    if (rule["<"]) {
      const [left, right] = rule["<"];
      return `${left.var} < ${right}`;
    }
    if (rule["<="]) {
      const [left, right] = rule["<="];
      return `${left.var} <= ${right}`;
    }
    if (rule.in) {
      const [val, left] = rule.in;
      return `${left.var} contains ${val}`;
    }
    if (rule["!"] && rule["!"].in) {
      const [val, left] = rule["!"].in;
      return `${left.var} !contains ${val}`;
    }
    return "Condition";
  };

  conditions.forEach((cond, i) => {
    y += 120;
    const id = `cond-${i}`;
    nodes.push({
      id,
      type: "condition",
      position: { x, y },
      data: { label: labelFromLogic(cond) },
      style: {
        background: "#000",
        color: "#fff",
        border: "1px solid #222",
      },
    });
    edges.push({
      id: `e-${lastNodeId}-${id}`,
      source: lastNodeId,
      target: id,
      type: "smoothstep",
    });
    lastNodeId = id;
  });

  // 3) Action nodes in step_order
  const sortedActions = [...actions].sort((a, b) => a.step_order - b.step_order);
  sortedActions.forEach((act, i) => {
    y += 120;
    const id = `action-${i}`;
    nodes.push({
      id,
      type: "action",
      position: { x, y },
      data: { label: `Action: ${act.action_type_id}` },
      style: {
        background: "#000",
        color: "#fff",
        border: "1px solid #222",
      },
    });
    edges.push({
      id: `e-${lastNodeId}-${id}`,
      source: lastNodeId,
      target: id,
      type: "smoothstep",
    });
    lastNodeId = id;
  });

  // 4) Log node showing last execution status
  y = 60;
  nodes.push({
    id: "log",
    type: "default",
    position: { x: 400, y },
    data: {
      label: `Last: ${executions[0]?.status || "n/a"}`,
    },
    style: {
      background: "#000",
      color: "#fff",
      border: "1px solid #222",
    },
  });
  // connect last action (or trigger) to log
  edges.push({
    id: `e-${lastNodeId}-log`,
    source: lastNodeId,
    target: "log",
    type: "smoothstep",
  });

  return { nodes, edges, labelFromLogic };
}
